// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Native base DateTime struct impl
class NativeDateTime {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeDateTime(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeDateTime.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) lookup)
      : _lookup = lookup;

  /// Day values for each month.
  late final ffi.Pointer<ffi.Pointer<ffi.Int>> _monthDays =
      _lookup<ffi.Pointer<ffi.Int>>('monthDays');

  ffi.Pointer<ffi.Int> get monthDays => _monthDays.value;

  set monthDays(ffi.Pointer<ffi.Int> value) => _monthDays.value = value;

  /// Creates DateTime with 2023 New Year date.
  ffi.Pointer<DateTime> createNewYear() {
    return _createNewYear();
  }

  late final _createNewYearPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<DateTime> Function()>>('createNewYear');
  late final _createNewYear = _createNewYearPtr.asFunction<ffi.Pointer<DateTime> Function()>();

  /// Change year of passed DateTime.
  ///
  /// \param time - pointer to DateTime struct.
  /// \param year - new year value.
  ///
  /// \throws std::invalid_argument - if year less than 1.
  void changeYear(
    ffi.Pointer<DateTime> time,
    int year,
  ) {
    return _changeYear(
      time,
      year,
    );
  }

  late final _changeYearPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<DateTime>, ffi.Int)>>('changeYear');
  late final _changeYear = _changeYearPtr.asFunction<void Function(ffi.Pointer<DateTime>, int)>();

  /// Change month of passed DateTime.
  ///
  /// \param time - pointer to DateTime struct.
  /// \param month - new month value.
  ///
  /// \throws std::invalid_argument - if month less than 1 or greater than 12.
  void changeMonth(
    ffi.Pointer<DateTime> time,
    int month,
  ) {
    return _changeMonth(
      time,
      month,
    );
  }

  late final _changeMonthPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<DateTime>, ffi.Int)>>('changeMonth');
  late final _changeMonth = _changeMonthPtr.asFunction<void Function(ffi.Pointer<DateTime>, int)>();

  /// Change day of passed DateTime.
  ///
  /// \param time - pointer to DateTime struct.
  /// \param day - new day value.
  ///
  /// \throws std::invalid_argument - if day less than 1 or greater than possible for [time->month] days.
  void changeDay(
    ffi.Pointer<DateTime> time,
    int day,
  ) {
    return _changeDay(
      time,
      day,
    );
  }

  late final _changeDayPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<DateTime>, ffi.Int)>>('changeDay');
  late final _changeDay = _changeDayPtr.asFunction<void Function(ffi.Pointer<DateTime>, int)>();
}

/// DateTime base struct.
///
/// Contains year, month and day to present day value.
class DateTime extends ffi.Struct {
  @ffi.Int()
  external int year;

  @ffi.Int()
  external int month;

  @ffi.Int()
  external int day;
}
